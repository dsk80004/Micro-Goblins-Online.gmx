<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Sets the font for user information.
draw_set_font(ft_example);

tile_width = 16; tile_height = 16;

// Specifies a z (depth) for the different tiles in form of a DS priority to pass over to the ats_init function below.
var priority = ds_priority_create();
ds_priority_add(priority, spr_example_tile_air, 0);
ds_priority_add(priority, spr_example_tile_dirt, 1);
ds_priority_add(priority, spr_example_tile_stone, -1);
ds_priority_add(priority, spr_example_tile_glass, -2);

// Initializes the Autotiling Tilemap Shaders extension (go to the script for more information).
ats_init(tile_width, tile_height, priority, 8);

// The DS priority is only temporary, so we can destroy it after the extension is initialized.
ds_priority_destroy(priority);

// Creates an ATS rectangle. This is an instance that visualizes tiles over a rectangular area.
ats_rectangle = ats_rectangle_create(room_width / tile_width, room_height / tile_height, false);

// Creates a grid for holding the sprites used for the tiles.
grid = ds_grid_create(room_width / tile_width, room_height / tile_height);

// Fills the grid with tile sprites for some example landscape.
if (file_exists("preset")) {
    // Loads tiles from an included file.
    var f = file_text_open_read("preset");
    ds_grid_read(grid, file_text_read_string(f));
    file_text_close(f);
} else {
    // Clears the area so it's just air.
    ds_grid_clear(grid, spr_example_tile_air);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Lets the user end the game.
if (keyboard_check_pressed(vk_escape)) {
    ats_free();
    game_end();
}

// Lets the user save the tile layout.
if (keyboard_check(vk_control) &amp;&amp; keyboard_check_pressed(ord("S"))) {
    var f = file_text_open_write("preset");
    file_text_write_string(f, ds_grid_write(grid));
    file_text_close(f);
}

// Lets the user shuffle the tiles.
if (keyboard_check(vk_space)) {
    ds_grid_shuffle(grid);
    ats_rectangle_update(ats_rectangle, grid, 0, 0, room_width / tile_width, room_height / tile_height);
}

// Lets the user place/remove tiles.
if (mouse_check_button(mb_any)) {
    // First line gets the tile position within the grid that corresponds to your mouse position. Second line changes the sprite value within the grid. Third line updates the part of the ATS rectangle that was changed.
    var t_x = floor(mouse_x / tile_width), t_y = floor(mouse_y / tile_height);
    if (mouse_button == mb_right) grid[# t_x, t_y] = spr_example_tile_air; else if (keyboard_check(vk_control)) grid[# t_x, t_y] = spr_example_tile_stone; else grid[# t_x, t_y] = spr_example_tile_dirt;
    ats_rectangle_update(ats_rectangle, grid, t_x, t_y, 1, 1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Visualizes the tiles in the grid.
ats_rectangle_draw(ats_rectangle, grid, undefined, undefined, undefined, undefined, 0, 0);

draw_set_color(c_black);

draw_text(8, 8, "FPS: " + string(fps) + "#Left mouse button to place dirt (hold &lt;Ctrl&gt; to place stone).#Right mouse button to remove tiles.#Hold &lt;Space&gt; to shuffle the tiles (shows the#runtime efficiency for updating the tiles).");

// Draws a grid for the tiles.
draw_set_alpha(0.25);
for (var t_x = tile_width - 1; t_x &lt; room_width; t_x += tile_width) draw_line(t_x, -1, t_x, room_height);
for (var t_y = tile_height - 1; t_y &lt; room_height; t_y += tile_height) draw_line(-1, t_y, room_width, t_y);
draw_set_alpha(1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
