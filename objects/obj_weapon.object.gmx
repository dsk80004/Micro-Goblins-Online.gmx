<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_weap_test</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>obj_weapon</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///define variable stats
w_name = "Default Weapon"
w_type = weapon_type_melee

w_damage = 1
w_knockback = 8
w_size = 1
w_speed = 180/(room_speed * 0.5)  //6 degrees at 60fps
proj_speed = 8
w_range = 16 * 20


//sprite_index = sprite_index
sprite_proj = sprite_index
range_weap_timer = 0  //used to stop drawing the weapon after attack since the two arent connected; otherwise the gun/box would only appear for a single frame

start_x = x
start_y = y
w_start_dir = 0
rot = 0
attack_speed = 0 //this is used in the future to calculate

owner_id = -1

attack = true
//attacking = false
distance_traveled = 0
dis = 16
pre_collide = false
collide = false

//modifier stats
active_queue = -1
weapon_event_queues = -1

//melee mods
stabbing = false //for the multi stab modifier
swiftness = 0
slowness  = 0
melee_ranged = 0
is_chained = false

//ranged mods

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///init variables
recent_proj_queue = -1
proj_queue = -1

self.step_event_queues = -1
self.step_event_queues_temp = -1

self.pre_col_queues = -1
self.pre_col_queues_temp = -1

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>trav_dis_dir = 0
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///clean up left over queues

if variable_instance_exists(id, "active_queue"){
  if active_queue != -1{
    if ds_exists(active_queue, ds_type_priority){
      ds_priority_destroy(active_queue)
      active_queue = -1
    }
  }
}

if variable_instance_exists(id, "recent_proj_queue"){
  if recent_proj_queue != -1{
    if ds_exists(recent_proj_queue, ds_type_queue){
      ds_queue_destroy(recent_proj_queue)
      recent_proj_queue = -1
    }
  }
}

if variable_instance_exists(id, "proj_queue"){
  if proj_queue != -1{
    if ds_exists(proj_queue, ds_type_queue){
      ds_queue_destroy(proj_queue)
      proj_queue = -1
    }
  }
}

if variable_instance_exists(id, "weapon_event_queues"){
  if weapon_event_queues != -1{
    if ds_exists(weapon_event_queues, ds_type_priority){
      ds_priority_destroy(weapon_event_queues)
      weapon_event_queues = -1
    }
  }
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Double Strike mod

var echo_inst;

self.echo_inst = instance_copy(false)
self.echo_inst.w_start_dir = self.w_start_dir
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Projectile spawn modifiers
////////////////////////////////////////////////////////////////////
//Projectile spawn modifiers
////////////////////////////////////////////////////////////////////
if self.attack  //if spawning projectiles
{
  //show_debug_message("weap - Projectile spawn modifiers")
  
  if (w_type = weapon_type_range) || (melee_ranged &gt; 0)
  {
    var self.distance = ((self.sprite_width*self.image_xscale)/2 + (self.sprite_height*self.image_yscale)/2) /2 +1
    var self.xx = x+lengthdir_x(self.distance, self.direction);
    var self.yy = y+lengthdir_y(self.distance, self.direction);
    
    //we store them in a queue so all modifiers can deal with all bullets
    self.recent_proj_queue = ds_queue_create()
    
    var self.proj = instance_create(xx, yy, obj_weap_proj)
    self.proj.direction = direction
    
    ds_queue_enqueue(self.recent_proj_queue, self.proj)
    //we also create a full queue to give these projectiles their step events in the next code block
    self.proj_queue = ds_queue_create()
    
    //copy the OG bullet into the queue because mod scripts will handle their spawned projetiles on their own
    ds_queue_copy(self.proj_queue, self.recent_proj_queue)
    
  }
  
  var self.result = scr_run_modifiers() //projectile spawn modifiers
  if self.result = true
  {
    if (w_type = weapon_type_range) || (melee_ranged &gt; 0)
    {
      ds_queue_destroy(self.recent_proj_queue)
      recent_proj_queue = -1
      
      while !ds_queue_empty(self.proj_queue)
      {
        var proj = ds_queue_dequeue(self.proj_queue);
        
        //copy the last of the queues to the projectile
        proj.weapon_event_queues = ds_priority_create()
        ds_priority_copy(proj.weapon_event_queues, self.weapon_event_queues)
        
        proj.owner_id = owner_id
        
        //proj.direction = direction
        proj.image_angle = proj.direction-45
        
        proj.sprite_index = sprite_proj
        //if (proj.sprite_index = sprite_index) {proj.image_angle -= 45}
        
        proj.image_xscale = w_size
        proj.image_yscale = w_size
        
        
        proj.start_x = proj.x
        proj.start_y = proj.y
        
        proj.w_damage = w_damage
        proj.w_range = w_range
        proj.w_knockback = w_knockback
        proj.speed = self.proj_speed //w_speed
        
      }
      ds_queue_destroy(self.proj_queue)
      proj_queue = -1
      
      if (w_type = weapon_type_range) //|| melee_ranged
      {
        self.owner_id.attack = false
        self.owner_id.post_attack = true
        draw_self()
        //instance_destroy()
      }
    }
    self.attack = false
    
  }
}




</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///annimate weapon

if (w_type = weapon_type_melee)
{
  //if no animation modifiers, then run defult slash
  
  //we put this at the top to ensure an exta frame of animation for the extremely fast melee weapons.
  
  if !variable_instance_exists(self.id, "anim_attack_start") {anim_attack_start = true}
  
  //set the animation variables
  if (anim_attack_start)
  {
    // anim_time is used to equate exactly how many frames the animation needs to take
    anim_attack_time = floor(room_speed*1)
    
    // anim_timer is used to equate where the sin/cos wave currently is
    anim_attack_timer = anim_attack_time
    
    // lastly max_-_multiplier is the maximum distance we want the axis to move, the cos/sin function would move it a parcent of the max
    anim_attack_max_direction_multiplier = 180
    
    // this variable is only used to make sure we only calculate the animation's variables once
    anim_attack_start = false
  }
  
  // reset values for ideal location (so modifiers can calculate new locations on their own)
  x = self.owner_id.x + lengthdir_x(dis, w_start_dir);
  y = self.owner_id.y + lengthdir_y(dis, w_start_dir);
  direction = w_start_dir;
  image_angle = direction-45;
  
  ///if attack is finished
  if (anim_attack_timer &lt;= 0)
  {
    self.owner_id.attack = false
    self.owner_id.post_attack = true
    
    if ds_exists(weapon_event_queues, ds_type_priority)
    {
      //show_debug_message("weapon finished")
      ds_priority_destroy(weapon_event_queues)
      weapon_event_queues = -1
    }
    
    instance_destroy()
  }
  
  anim_attack_timer -= 1*lag()
  
  //
  //
  //
  //
  //
  /*
  attack_speed = (w_speed * (1+swiftness)) /(1+slowness)
  rot += attack_speed
  image_angle -= attack_speed
  if (rot &amp;gt;= 180) {image_angle = w_end_dir}
  if (image_angle &amp;gt;= 360) {image_angle -= 360}
  */
}  



if (w_type = weapon_type_range) &amp;&amp; (self.attack = false)
{
  range_weap_timer += 1
  if (range_weap_timer &gt;= room_speed/4)
  {
    instance_destroy()
  }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Attack step event

////////////////////////////////////////////////////////////////////
//Attack step event
////////////////////////////////////////////////////////////////////
if !self.attack &amp;&amp; !self.collide &amp;&amp; !self.pre_collide  //if spawning projectiles
{
  //show_debug_message("weap - Attack step event")
  
  if !ds_exists(self.step_event_queues, ds_type_priority)
  {
    self.step_event_queues = ds_priority_create()
    ds_priority_copy(self.step_event_queues, ds_priority_delete_min(self.weapon_event_queues))
  }
  
  //dont delete the queue untill the collision actually happens
  //so instead we make a copy to deal with
  if !ds_exists(self.step_event_queues_temp, ds_type_priority)
  {
    self.step_event_queues_temp = ds_priority_create()
    ds_priority_copy(self.step_event_queues_temp, self.step_event_queues)
  }
  
  //check to see if there is even anything in the step queue
  if !ds_priority_empty(self.step_event_queues){
    
    while !ds_priority_empty(self.step_event_queues_temp)
    {
      scr = script_execute(ds_priority_delete_min(self.step_event_queues_temp))
    }
    
    if ds_priority_empty(self.step_event_queues_temp)
    {
      ds_priority_copy(self.step_event_queues_temp, self.step_event_queues)
    }
  }
  
  //ds_priority_delete_min(weapon_event_queues)
  //dont delete the queue untill the collision actually happens
  
  //var self.result = scr_run_modifiers() //pre collision modifiers
  //if self.result = true
  //{
  //  
  //}
  
  //if (distance_to_point(start_x, start_y) &gt;= w_range)
  //{
  //  self.pre_collide = true
  //}
  if place_meeting(x, y, obj_entity)
  {
    if place_meeting(x, y, obj_enemy)
    {
      var enemy;
      enemy = instance_nearest(x, y, obj_enemy)
      enemy.sprite_index = spr_yellow
      
      enemy.spd = self.w_knockback
      enemy.direction = direction //point_direction(x, y, enemy.x, enemy.y)
    }
  }
}



</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Pre collision modifiers

////////////////////////////////////////////////////////////////////
//Pre collision modifiers
////////////////////////////////////////////////////////////////////
if !self.attack &amp;&amp; !self.collide &amp;&amp; self.pre_collide //if collision is detected, before collision is for sure
{
  //show_debug_message("weap - Pre collision modifiers")
  
  var self.result = scr_run_modifiers() //pre collision modifiers like boomerange
  if self.result = true
  {
    self.attack = false
  }
}




</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///collision modifiers

////////////////////////////////////////////////////////////////////
//collision modifiers
////////////////////////////////////////////////////////////////////
if !self.attack &amp;&amp; self.collide  //if officially collided
{
  //show_debug_message("weap - collision modifiers")
  var self.result = scr_run_modifiers() //collision modifiers
  if self.result = true
  {
    self.attack = false
  }
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//draw sword movement

if (attack_speed !=0)
{var flicks = clamp((swiftness+3)-slowness, 0, 8)}
else
{var flicks = 0}

if (flicks != 0)
{var flicker_rot = attack_speed/(flicks+1)}
else
{
var flicker_rot = 0}

var xx, yy;


for (var i = 1; i &lt;= flicks; i++)
{
  xx[i]  = self.owner_id.x + lengthdir_x(dis, image_angle+45+flicker_rot*i);
  yy[i]  = self.owner_id.y + lengthdir_y(dis, image_angle+45+flicker_rot*i);

  draw_sprite_ext(sprite_index,image_index,xx[i],yy[i],image_xscale,image_yscale,image_angle+(flicker_rot*i),image_blend, (image_alpha/flicks)*(flicks-i)); 
}


// if the weapon in chained, draw the chain
if (is_chained){
  //for now we're just going to draw a line to player center
  draw_line_colour(x, y, owner_id.x, owner_id.y, c_black, c_black)
  
}

draw_self()

draw_circle(owner_id.x+lengthdir_x(dis, trav_dis_dir), owner_id.y+lengthdir_y(dis, trav_dis_dir), 1, false)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
