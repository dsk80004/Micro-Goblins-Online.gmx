<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_chunk</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>tile_layer_bottom_list = -1
tile_layer_middle_list = -1
tile_layer_top_list = -1
tile_layer_decor_list = -1
tile_layer_bottom_background_list = -1
tile_layer_middle_background_list = -1
tile_layer_top_background_list = -1
tile_layer_decor_background_list = -1

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Have Existential Crisis
//find out if you should even exist


should_exist = true
var margin = 0
//is the player with in distance of you?
var player = instance_nearest(x+sprite_width/2, y+sprite_height/2, obj_player)

if !point_in_rectangle(player.x, player.y, bbox_left-(sprite_width*chunk_dist)-margin, bbox_top-(sprite_height*chunk_dist)-margin, bbox_right+(sprite_width*chunk_dist)+margin, bbox_bottom+(sprite_height*chunk_dist)+margin){
  should_exist = false
  //show_debug_message("Chunk: ("+string(chunk_x)+","+string(chunk_y)+") Should NOT exists")
}//else{
  //show_debug_message("Chunk: ("+string(chunk_x)+","+string(chunk_y)+") Should exists")
//}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Stagger the chunk Saving

if should_exist = false {
  if (global.chunk_handler.chunk_saved_this_frame = false){
    global.chunk_handler.chunk_saved_this_frame = true
    //show_debug_message("global.chunk_handler.chunk_saved_this_frame = false")
    event_user(1);
  }else{
    alarm_set(3, 1)
    //show_debug_message("global.chunk_handler.chunk_saved_this_frame = TRUE!!!")
    
  }
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Stagger the chunk Loading

if (global.chunk_handler.chunk_loaded_this_frame = false){
  global.chunk_handler.chunk_loaded_this_frame = true
  //show_debug_message("global.chunk_handler.chunk_loaded_this_frame = false")
  event_user(4);
}else{
  alarm_set(2, 1)
  //show_debug_message("global.chunk_handler.chunk_loaded_this_frame = TRUE!!!")
  
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Stagger the chunk gen

if (global.chunk_handler.chunk_gen_this_frame = false){
  global.chunk_handler.chunk_gen_this_frame = true
  //show_debug_message("global.chunk_handler.chunk_gen_this_frame = false")
  event_user(2);
}else{
  alarm_set(1, 1)
  //show_debug_message("global.chunk_handler.chunk_gen_this_frame = TRUE!!!")
  
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Save every 2 minutes.

if (global.chunk_handler.chunk_saved_this_frame = false){
  global.chunk_handler.chunk_saved_this_frame = true
  chunk_save_to_disk()
  
  alarm_set(0, room_speed*60*2)
}else{
  alarm_set(0, 1)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Loading

if (async_load[? "id"] == loadid) {
  if (async_load[? "status"] = 1) { 
    
    chunk_data = ds_map_secure_load_buffer(load_buff);
    //show_debug_message("Chunk: ("+string(chunk_x)+","+string(chunk_y)+") async active")
    
    ///make sure to check the chunk to know it saved/loaded properly
    if chunk_data[? "TileLayerBottom"] = undefined
    || chunk_data[? "TileLayerMiddle"] = undefined
    || chunk_data[? "TileLayerTop"] = undefined
    || chunk_data[? "TileLayerDecor"] = undefined
    || chunk_data[? "TileLayerBottomBackground"] = undefined
    || chunk_data[? "TileLayerMiddleBackground"] = undefined
    || chunk_data[? "TileLayerTopBackground"] = undefined
    || chunk_data[? "TileLayerDecorBackground"] = undefined
    {
      ds_map_destroy(chunk_data);
      show_debug_message("[Chunk][Load]: Chunk File ("+string(chunk_x)+","+string(chunk_y)+") was currupted, regenerating")
      chunk_data = chunk_generate()
    }
    
    
    alarm_set(1,1)
    
  }else{ // If there was an error loading, try to load again
    event_user(0)
    ///this may need to be fixed because it could cause for an infinate loop. but it works for now
  }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Load Chunk data

_filename = "default\"+"Worlds\"+string(world_name)+"\"+string(chunk_x)+","+string(chunk_y)+".chnk"

if file_exists(_filename){
  //load the chunk data here
  chunk_data = -1
  load_buff = buffer_create(128,buffer_grow,4)
  loadid = buffer_load_async(load_buff, _filename, 0, 2500000);
  ///When ever you add new stuff to the save chunks you'll need to find
  // out how large the file ends up being, but 32,768 bytes is the size
  // for 4 tile layers.
}else{
  chunk_data = -1
  chunk_data = chunk_generate()
  //event_user(2)
  //show_debug_message(_filename+" does NOT exists!")
}





</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Place Chunk Data


if ds_exists(chunk_data, ds_type_map) {
    ///variables
    var tile_size = 16;
    list_pointer = 0;
    
    // Decompile Map
    tile_layer_bottom_list = chunk_data[? "TileLayerBottom"];
    tile_layer_middle_list = chunk_data[? "TileLayerMiddle"];
    tile_layer_top_list = chunk_data[? "TileLayerTop"];
    tile_layer_decor_list = chunk_data[? "TileLayerDecor"];
    
    tile_layer_bottom_background_list = chunk_data[? "TileLayerBottomBackground"];
    tile_layer_middle_background_list = chunk_data[? "TileLayerMiddleBackground"];
    tile_layer_top_background_list = chunk_data[? "TileLayerTopBackground"];
    tile_layer_decor_background_list = chunk_data[? "TileLayerDecorBackground"];
    
    // Bottom
    var b_layer = TileLayerBottom
    
    // MIDDLE
    var m_layer = TileLayerMiddle
    
    // TOP
    var t_layer = TileLayerTop
    
    // DECOR
    var d_layer = TileLayerDecor
    
    // do a single cycle through the chunk
    for (var i = 0; i &lt; sprite_height; i += tile_size){
      for (var j = 0; j &lt; sprite_width; j += tile_size){
        //bottom
        var pos = tile_layer_bottom_list[| list_pointer]
        var bg = tile_layer_bottom_background_list[| list_pointer] 
        if (pos != -1) &amp;&amp; (bg != -1) {
          var ww = background_get_width(bg) div tile_size,
              xx = pos mod ww,
              yy = pos div ww;
            
          tile_add(bg, xx*tile_size, yy*tile_size, tile_size, tile_size, x+j, y+i, b_layer);
        }
        
        
        //middle
        var pos = tile_layer_middle_list[| list_pointer]
        var bg = tile_layer_middle_background_list[| list_pointer] 
        if (pos != -1) &amp;&amp; (bg != -1) {
          var ww = background_get_width(bg) div tile_size,
              xx = pos mod ww,
              yy = pos div ww;
            
          tile_add(bg, xx*tile_size, yy*tile_size, tile_size, tile_size, x+j, y+i, m_layer);
        }
        
        
        //top
        var pos = tile_layer_top_list[| list_pointer]
        var bg = tile_layer_top_background_list[| list_pointer] 
        if (pos != -1) &amp;&amp; (bg != -1) {
          var ww = background_get_width(bg) div tile_size,
              xx = pos mod ww,
              yy = pos div ww;
            
          tile_add(bg, xx*tile_size, yy*tile_size, tile_size, tile_size, x+j, y+i, t_layer);
        }
        
        
        //decor
        var pos = tile_layer_decor_list[| list_pointer]
        var bg = tile_layer_decor_background_list[| list_pointer] 
        if (pos != -1) &amp;&amp; (bg != -1) {
          var ww = background_get_width(bg) div tile_size,
              xx = pos mod ww,
              yy = pos div ww;
            
          tile_add(bg, xx*tile_size, yy*tile_size, tile_size, tile_size, x+j, y+i, d_layer);
        }
        
        list_pointer++
      }
      
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///If chunk shouldnt exist Save Data

if should_exist = false{
  if ds_exists(chunk_data, ds_type_map) {
    chunk_save_to_disk()
  }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Destroy tiles and object

if should_exist = false{
  if ds_exists(chunk_data, ds_type_map) {
    var tile_size = 16
    
    // Bottom
    var b_layer = TileLayerBottom
    
    // MIDDLE
    var m_layer = TileLayerMiddle
    
    // TOP
    var t_layer = TileLayerTop
    
    // DECOR
    var d_layer = TileLayerDecor
    
    // Full Cycle
    for (var i = 0; i &lt; sprite_height; i += tile_size){
      for (var j = 0; j &lt; sprite_width; j += tile_size){
        tile_layer_delete_at(b_layer, x+j, y+i);
        tile_layer_delete_at(m_layer, x+j, y+i);
        tile_layer_delete_at(t_layer, x+j, y+i);
        tile_layer_delete_at(d_layer, x+j, y+i);
      }
    }
    
  }  
    
    var active_chunk = id
    
    with (obj_solid){
      if point_in_rectangle(x,y, active_chunk.bbox_left, active_chunk.bbox_top, active_chunk.bbox_right, active_chunk.bbox_bottom){
        instance_destroy()
      }
    }
  
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Destroy Self

if should_exist = false{
  
  // Clean Up
  if ds_exists(chunk_data, ds_type_map) ds_map_destroy(chunk_data);
  instance_destroy()
  
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Check for already existing objects in the chunk

objects_in_chunk = false
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///queue up the loading

if (objects_in_chunk = false){
  alarm_set(2,1)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///[Debug] Show Chunks

if (show_chunks) {
  var chunk_string = "("+string(chunk_x)+","+string(chunk_y)+")";
  var scale = obj_camera_control.upscale_val/2;
  draw_set_colour(c_yellow)
  draw_rectangle(bbox_left-1, bbox_top-1, bbox_right, bbox_bottom, true)
  draw_set_font(font_debug)
  draw_text_transformed(x,y,chunk_string,1*scale, 1*scale, 0)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
