<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_chunk</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
tile_layer_bottom_grid = -1
tile_layer_middle_grid = -1
tile_layer_top_grid = -1
tile_layer_decor_grid = -1
tile_layer_bottom_background_grid = -1
tile_layer_middle_background_grid = -1
tile_layer_top_background_grid = -1
tile_layer_decor_background_grid = -1
*/

chunk_data = -1
should_exist = true

//exterior chunk data
heightmap_grid = -1
structures_grid = -1

//interior chunk data
interior_grid_x = -1
interior_grid_y = -1
interior_map = -1


terrain_surface = -1

generated = false;



</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>image_alpha = 0.25
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Have Existential Crisis
//find out if you should even exist

var margin = global.chunk_handler.margin
var chunk_dist = global.chunk_handler.chunk_dist

//is the player with in distance of you?
var player = instance_nearest(x+sprite_width/2, y+sprite_height/2, obj_player)

var closest_x = player.x div sprite_width
var closest_y = player.y div sprite_height

x_diff = closest_x - chunk_x
y_diff = closest_y - chunk_y

//if !point_in_rectangle(player.x, player.y, bbox_left-(sprite_width*(chunk_dist+margin)), bbox_top-(sprite_height*(chunk_dist+margin)), bbox_right+(sprite_width*(chunk_dist+margin)), bbox_bottom+(sprite_height*(chunk_dist+margin))){
if not ((abs(x_diff) &lt; chunk_dist+margin) &amp;&amp; (abs(y_diff) &lt; chunk_dist+margin)){
  should_exist = false
  //show_debug_message("Chunk: ("+string(chunk_x)+","+string(chunk_y)+") Should NOT exists")
}



</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// /* Stagger the chunk Saving

if should_exist = false {
  if (global.chunk_handler.chunk_saved_this_frame = false &amp;&amp; global.chunk_handler.chunk_loaded_this_frame = false) || (generated = false) || (heightmap_grid = -1){
    global.chunk_handler.chunk_saved_this_frame = true
    //show_debug_message("global.chunk_handler.chunk_saved_this_frame = false")
    event_user(1);
  }else{
    alarm_set(3, 1)
    //show_debug_message("global.chunk_handler.chunk_saved_this_frame = TRUE!!!")
    
  }
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Stagger the chunk Loading

if (global.chunk_handler.chunk_loaded_this_frame = false){
  global.chunk_handler.chunk_loaded_this_frame = true
  //show_debug_message("global.chunk_handler.chunk_loaded_this_frame = false")
  event_user(4);
}else{
  alarm_set(2, 1)
  //show_debug_message("global.chunk_handler.chunk_loaded_this_frame = TRUE!!!")
  
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Stagger the chunk gen

if (global.chunk_handler.chunk_gen_this_frame = false){
  global.chunk_handler.chunk_gen_this_frame = true
  //show_debug_message("global.chunk_handler.chunk_gen_this_frame = false")
  event_user(2);
}else{
  alarm_set(1, 1)
  //show_debug_message("global.chunk_handler.chunk_gen_this_frame = TRUE!!!")
  
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// /* Save to map every 2 minutes.
/*
if (global.chunk_handler.chunk_saved_this_frame = false){
  global.chunk_handler.chunk_saved_this_frame = true
  //chunk_save_to_map()
  //show_debug_message("Chunk: ("+string(chunk_x)+","+string(chunk_y)+") Saved")
  
  alarm_set(0, room_speed*60*2)
}else{
  alarm_set(0, 1)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// /* Loading
/*
//if ds_exists(async_load, ds_type_map){
if (async_load[? "id"] == loadid) {
  if (async_load[? "status"] = 1) { 
    show_debug_message("===============================TRYING TO LOAD!!!========================")
    chunk_data = ds_map_secure_load_buffer(load_buff);
    //if buffer_exists(load_buff)
    buffer_delete(load_buff);
    
    //show_debug_message("Chunk: ("+string(chunk_x)+","+string(chunk_y)+") async active")
    
    ///make sure to check the chunk to know it saved/loaded properly
    if !ds_exists(chunk_data, ds_type_map)
    || chunk_data[? "TileLayerBottom"] = undefined
    || chunk_data[? "TileLayerMiddle"] = undefined
    || chunk_data[? "TileLayerTop"] = undefined
    || chunk_data[? "TileLayerDecor"] = undefined
    || chunk_data[? "TileLayerBottomBackground"] = undefined
    || chunk_data[? "TileLayerMiddleBackground"] = undefined
    || chunk_data[? "TileLayerTopBackground"] = undefined
    || chunk_data[? "TileLayerDecorBackground"] = undefined
    {
      if ds_exists(chunk_data, ds_type_map) ds_map_destroy(chunk_data);
      show_debug_message("[Chunk][Load]: Chunk File ("+string(chunk_x)+","+string(chunk_y)+") was currupted, regenerating")
      chunk_data = chunk_generate()
    }
    
    
    alarm_set(1,1)
    //ds_map_destroy(async_load)
  }else{ // If there was an error loading, try to load again
    //ds_map_destroy(async_load)
    //show_debug_message("#####  THERE WAS AN ERROR LOADING!!!  #####")
    event_user(0)
    ///this may need to be fixed because it could cause for an infinate loop. but it works for now
  
  }
}
//}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Load Chunk data

//_filename = "default\"+"Worlds\"+string(world_name)+"\"+string(chunk_x)+","+string(chunk_y)+".chnk"
//_filename = "Worlds\"+string(world_name)+"\"+string(chunk_x)+","+string(chunk_y)+".chnk"
if (should_exist = false){
  event_user(1)
  exit;
}

//if the cell is an exterior cell
if ds_exists(global.chunk_handler.world_map, ds_type_map){
  //load the chunk data here
  if !is_interior(x,y){
    chunk_generate()
  }else{
    chunk_generate_interior_room()
  }
  
  alarm_set(1,1)
  
}else{
  
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create Chunk Surface  
  var tile_size = global.chunk_handler.tile_size
  var width  = global.chunk_handler.world_width
  var height = global.chunk_handler.world_height
  
  var x_off = bbox_left/tile_size;
  var y_off = bbox_top/tile_size;
  
  terrain_surface = surface_create(sprite_width, sprite_height)
  
  surface_set_target(terrain_surface)
  //*
  var tiles_x = sprite_width/tile_size;
  var tiles_y = sprite_height/tile_size;
  
  
if !is_interior(x,y){ //exterior cells
  if(ds_grid_get_max(heightmap_grid, 0,0,width,height) &lt;=1){ // If max value of our grid is less or equal 1, then poceed without autotiling.
    
    
    for(var i = 0; i &lt; tiles_x; i++){
      for(var j = 0; j &lt; tiles_y; j++){
    
        //heightmap tiles
        if(heightmap_grid[#i, j] &lt;= 0.15){draw_sprite(tile_water, 0, (i*tile_size), (j*tile_size));}
        else if(heightmap_grid[#i, j] &gt; 0.15 &amp;&amp; heightmap_grid[#i, j] &lt; 0.25){draw_sprite(tile_sand, 0, i*tile_size, j*tile_size);}
        else if(heightmap_grid[#i, j] &gt;= 0.25 &amp;&amp; heightmap_grid[#i, j] &lt;= 0.6){draw_sprite(tile_grass, 0, i*tile_size, j*tile_size);}
        else if(heightmap_grid[#i, j] &gt; 0.6 &amp;&amp; heightmap_grid[#i, j] &lt;= 0.7){draw_sprite(tile_dirt, 0, i*tile_size, j*tile_size);}
        else if(heightmap_grid[#i, j] &gt; 0.7 &amp;&amp; heightmap_grid[#i, j] &lt;= 0.8){draw_sprite(tile_rock, 0, i*tile_size, j*tile_size);}
        else if(heightmap_grid[#i, j] &gt; 0.8){draw_sprite(tile_snow, 0, i*tile_size, j*tile_size);}//
        
        //dungeon tiles
        if (structure_grid[#i, j] = 1){ draw_sprite(spr_black, 0, i*tile_size, j*tile_size); }
        if (structure_grid[#i, j] = 2){ draw_sprite(spr_black, 0, i*tile_size, j*tile_size); }
        if (structure_grid[#i, j] = 3){ draw_sprite(spr_black, 0, i*tile_size, j*tile_size); }
        if (structure_grid[#i, j] = 4){ draw_sprite(spr_red, 0, i*tile_size, j*tile_size); }
      }
    }
  }



}else{ //if it's an interior cell
  //show_debug_message("interior")
  /*
  if ds_exists(interior_map, ds_type_map){
    //first grab the cells
    var chunk_id_grid  = interior_map[? "chunk_id_grid"]
    var room_grid = interior_map[? "room_grid"]
    var grid_x = interior_grid_x
    var grid_y = interior_grid_y
    
    if (id = chunk_id_grid[# grid_x, grid_y]){
      interior_string = room_grid[# grid_x, grid_y]
    }
    
    */
  if variable_instance_exists(id, "interior_string") &amp;&amp; (interior_string != ""){
    
    //show_debug_message("interior string exists")
    var str = interior_string
    
    //show_debug_message("interior_string = "+string(interior_string))
    //show_debug_message("str = "+string(str))
    
    for(var i = 0; i &lt; tiles_x; i++){
      for(var j = 0; j &lt; tiles_y; j++){
        var value = obsticals_grid[# i, j]
        draw_sprite(spr_dungeon_tiles, value, i*tile_size, j*tile_size)
      }
    }
  
  }
}


if (show_chunks) {
    //draw chunk boarders
      var chunk_str = "("+string(chunk_x)+","+string(chunk_y)+")";
      var scale = 1//obj_camera_control.upscale_val/2;
      draw_set_colour(c_yellow)
      draw_rectangle(0, 0, sprite_width, sprite_height, true)
      draw_set_font(font_debug)
      draw_text_transformed(x,y,chunk_str,1*scale, 1*scale, 0)
    }
    
    
    surface_reset_target()                
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///clean up the left over noise

//if variable_instance_exists(id, "landmass"){
//  gpu_noise_free(landmass)
//}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// /* If chunk shouldnt exist Save Data
/*
if should_exist = false{
  if ds_exists(chunk_data, ds_type_map) {
//    chunk_save_to_map()
  }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// /* Destroy tiles and object
/*
if should_exist = false{
  if ds_exists(chunk_data, ds_type_map) {
    var tile_size = 16
    var chunk_width = sprite_width/tile_size;
    var chunk_height = sprite_height/tile_size;
    
    // Bottom
    var b_layer = TileLayerBottom
    
    // MIDDLE
    var m_layer = TileLayerMiddle
    
    // TOP
    var t_layer = TileLayerTop
    
    // DECOR
    var d_layer = TileLayerDecor
    
    //Make sure the grids exist before we try to read from them
    if ds_exists(tile_layer_bottom_grid, ds_type_grid) 
    &amp;&amp; ds_exists(tile_layer_middle_grid, ds_type_grid) 
    &amp;&amp; ds_exists(tile_layer_top_grid, ds_type_grid) 
    &amp;&amp; ds_exists(tile_layer_decor_grid, ds_type_grid) 
    {
      // Full Cycle
      for (var i = 0; i &lt; chunk_width; i++){
        for (var j = 0; j &lt; chunk_height; j++){
          var xx = x+i*tile_size
          var yy = y+j*tile_size
          
          if (tile_layer_bottom_grid[# i, j] != -1) tile_layer_delete_at(b_layer, xx, yy);
          if (tile_layer_middle_grid[# i, j] != -1) tile_layer_delete_at(m_layer, xx, yy);
          if (tile_layer_top_grid[# i, j] != -1) tile_layer_delete_at(t_layer, xx, yy);
          if (tile_layer_decor_grid[# i, j] != -1) tile_layer_delete_at(d_layer, xx, yy);
        }
      }
    }
    
  }  
    /*
    var active_chunk = id
    
    with (obj_solid){
      if point_in_rectangle(x,y, active_chunk.bbox_left, active_chunk.bbox_top, active_chunk.bbox_right, active_chunk.bbox_bottom){
        instance_destroy()
      }
    }
  */
//}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Destroy Self

if should_exist = false{
  /*
  // Clean Up
  if ds_exists(chunk_data, ds_type_map) {
    ds_map_destroy(chunk_data);
    
    if ds_exists(tile_layer_bottom_grid, ds_type_grid) ds_grid_destroy(tile_layer_bottom_grid)
    if ds_exists(tile_layer_middle_grid, ds_type_grid) ds_grid_destroy(tile_layer_middle_grid)
    if ds_exists(tile_layer_top_grid, ds_type_grid) ds_grid_destroy(tile_layer_top_grid)
    if ds_exists(tile_layer_decor_grid, ds_type_grid) ds_grid_destroy(tile_layer_decor_grid)
    if ds_exists(tile_layer_bottom_background_grid, ds_type_grid) ds_grid_destroy(tile_layer_bottom_background_grid)
    if ds_exists(tile_layer_middle_background_grid, ds_type_grid) ds_grid_destroy(tile_layer_middle_background_grid)
    if ds_exists(tile_layer_top_background_grid, ds_type_grid) ds_grid_destroy(tile_layer_top_background_grid)
    if ds_exists(tile_layer_decor_background_grid, ds_type_grid) ds_grid_destroy(tile_layer_decor_background_grid)
  }
  */
  if ds_exists(heightmap_grid, ds_type_grid){
    ds_grid_destroy(heightmap_grid)
  }
  
  if variable_instance_exists(id, "terrain_surface"){
    surface_free(terrain_surface)
  }
  
  chunk_forget(chunk_x, chunk_y)
  
  instance_destroy()
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Check for already existing objects in the chunk

objects_in_chunk = false
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///queue up the loading

if (objects_in_chunk = false){
  alarm_set(2,1)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Chunk

if is_visible(){
  if (terrain_surface != -1) || surface_exists(terrain_surface){   ///if ds_exists(heightmap_grid, ds_type_grid){
    draw_set_alpha(1)
    scr_draw_2dig()
    draw_set_alpha(1)
    //draw_self()
  }else{
    draw_self()
  }
  
    if (show_chunks) {
    var chunk_debug_string = "("+string(chunk_x)+","+string(chunk_y)+")"+"#x = "+string(x)+"#y = "+string(y);
    var scale = obj_camera_control.upscale_val/2;
    draw_set_colour(c_yellow)
    draw_set_font(font_debug)
    draw_text_transformed(x,y,chunk_debug_string,1*scale, 1*scale, 0)
  }

}



</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
