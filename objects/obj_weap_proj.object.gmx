<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_weap_test</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///init variables

dis_traveled = 0
do_not_collide = false
collide_ground = false
collide_enemy  = false
collide_solid  = false
collision_active = true

w_range = 16*10  //this value is only here incase we have an error
self.collide = false
self.pre_collide = false

///  we now activate all projectiles after the spawn projectiles mods are finished,
//     to prevent them from trying to run their modifiers which they dont have yet.
self.projectile_active = false

self.active_queue = -1
self.weapon_event_queues = -1

self.step_event_queues = -1
self.step_event_queues_temp = -1

self.pre_col_queues = -1
self.pre_col_queues_temp = -1

self.constant_timer = 0


previous_locations_steps = room_speed*0.1
previous_locations_step = 0
previous_locations_i = 0

//previous_locations_array[0, 0] = x
//previous_locations_array[0, 1] = y

previous_locations_path = path_add();
path_set_closed(previous_locations_path, false);
path_add_point(previous_locations_path, x, y, speed);

//lag handler
queued_to_del = false

///modifier variables
is_lasered = false
is_clustered = false
is_airstrike = false
is_arcLightning = false

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///init breakable object

//initialize breakable object (typically in the create event)
breaking = false
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///init draw variables

predraw_finished = false
draw_finished = false
postdraw_finished = false

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///destroy left over paths

path_delete(previous_locations_path)

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///clean up left over queues

if ds_exists(self.pre_col_queues_temp, ds_type_priority){
            ds_priority_destroy(self.pre_col_queues_temp)
            self.pre_col_queues_temp = -1
          }
          if ds_exists(self.pre_col_queues, ds_type_priority){
            ds_priority_destroy(self.pre_col_queues)
            self.pre_col_queues = -1
          }
          if ds_exists(self.step_event_queues_temp, ds_type_priority){
            ds_priority_destroy(self.step_event_queues_temp)
            self.step_event_queues_temp = -1
          }
          if ds_exists(self.step_event_queues, ds_type_priority){
            ds_priority_destroy(self.step_event_queues)
            self.step_event_queues = -1
          }
          //if ds_exists(self.weapon_event_queues, ds_type_priority){
          //  ds_priority_destroy(self.weapon_event_queues)
          //  self.weapon_event_queues = -1
          //}
          
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///sprite explode


if (collision_active)
&amp;&amp; (projectile_active)
&amp;&amp; !variable_instance_exists(self.id, "aoe_start")
&amp;&amp; (instance_number(obj_weap_proj) &lt; 25)
&amp;&amp; !enough_lag(){
  draw_sprite_explode(sprite_index)
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///disable and enable projectiles



///disable entity if out of bounds from all local players

//grab the max view radius
var r = obj_camera_control.max_view_radius
var max_r = r*2

var entity_x = x
var entity_y = y
var out_of_bounds_count = 0

entity_active = false;
var ent = self;

//with all players
with (obj_player){
  //grab the location
  var xx = x
  var yy = y
  var dist = point_distance(entity_x, entity_y, xx, yy)
  
  
  //find out if they are a local player
  if (player_id_local != -1){
    //find out if the entity is even with in bounds of the view
    if (dist &lt; r){
      ent.entity_active = true;
      ent.visible = true
      break;
    }else{
      ent.visible = false
    }
  }
  
  //find out if the entity is close ish to a player, if it's not we can probable safely delete it
  //We do this for all players to prevent an object from desyncing with other players
  if (dist &gt; max_r){
    out_of_bounds_count++
  }
}

if (out_of_bounds_count = global.numberOfGlobalPlayers){
  instance_destroy(ent)
}






</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///store previous locations

if every_other_frame() &amp;&amp; projectile_active{
  if !enough_lag(){
  
    previous_locations_step += 1
    
    if (previous_locations_step = previous_locations_steps){
        previous_locations_step = 0
        previous_locations_i +=1
        
        previous_locations_array[previous_locations_i, 0] = x
        previous_locations_array[previous_locations_i, 1] = y
        path_add_point(previous_locations_path, x, y, speed);
        //show_debug_message("Stored new value")
    }
  }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Run Modifiers

if (projectile_active)// &amp;&amp; entity_active)
//&amp;&amp; ticked_over()
{
  ////////////////////////////////////////////////////////////////////
  //Attack step event
  ////////////////////////////////////////////////////////////////////
  if !self.collide &amp;&amp; !self.pre_collide  //if spawning projectiles
  {
    //show_debug_message("proj - Attack step event")
    
    if !ds_exists(self.step_event_queues, ds_type_priority)
    {
      self.step_event_queues = ds_priority_create()
      ds_priority_copy(self.step_event_queues, ds_priority_delete_min(self.weapon_event_queues))
    }
    
    //dont delete the queue untill the collision actually happens
    //so instead we make a copy to deal with
    if !ds_exists(self.step_event_queues_temp, ds_type_priority)
    {
      self.step_event_queues_temp = ds_priority_create()
      ds_priority_copy(self.step_event_queues_temp, self.step_event_queues)
    }
    
    //check to see if there is even anything in the step queue
    if !ds_priority_empty(self.step_event_queues){
      
      while !ds_priority_empty(self.step_event_queues_temp)
      {
        scr = script_execute(ds_priority_delete_min(self.step_event_queues_temp))
      }
      
      if ds_priority_empty(self.step_event_queues_temp)
      {
        ds_priority_copy(self.step_event_queues_temp, self.step_event_queues)
      }
    }
    
    ///if we are about to collide
    dis_traveled += speed
    if (collision_active){
      col_proj_ground()
      col_proj_solid()
      col_proj_enemy() //this function will not activate when colliding with an ally or a friendly summon
    }else{
      //instance_destroy()
    }
  }
  
  
  ////////////////////////////////////////////////////////////////////
  //Pre collision modifiers
  ////////////////////////////////////////////////////////////////////
  if !self.collide &amp;&amp; self.pre_collide //if collision is detected, before collision is for sure
  {
    //show_debug_message("proj - Pre collision modifiers")
    
    self.do_not_collide = false
    
    if !ds_exists(self.pre_col_queues, ds_type_priority)
    {
      self.pre_col_queues = ds_priority_create()
      ds_priority_copy(self.pre_col_queues, ds_priority_delete_min(self.weapon_event_queues))
    }
    //dont delete the queue untill the collision actually happens
    //so instead we make a copy to deal with
    if !ds_exists(self.pre_col_queues_temp, ds_type_priority){
      self.pre_col_queues_temp = ds_priority_create()
      ds_priority_copy(self.pre_col_queues_temp, self.pre_col_queues)
    }
    
    //cycle through all pre collision modifiers, when the modifier is finished it'll return true
    while !ds_priority_empty(self.pre_col_queues_temp){
      var scr = ds_priority_delete_min(self.pre_col_queues_temp)
      var returned = script_execute(scr)
      if (returned = true) {ds_priority_delete_value(self.pre_col_queues, scr)}
    }
    
    //refill the temp list
    if ds_priority_empty(self.pre_col_queues_temp){
      ds_priority_copy(self.pre_col_queues_temp, self.pre_col_queues)
    }
    
    
    //if pre coliisions are empty then we must have collided
    if (ds_priority_empty(self.pre_col_queues) || !do_not_collide) &amp;&amp; self.collide = false &amp;&amp; self.pre_collide = true{
          ////if collision is final destroy the left over queues
          if ds_exists(self.pre_col_queues_temp, ds_type_priority){
            ds_priority_destroy(self.pre_col_queues_temp)
            self.pre_col_queues_temp = -1
          }
          if ds_exists(self.pre_col_queues, ds_type_priority){
            ds_priority_destroy(self.pre_col_queues)
            self.pre_col_queues = -1
          }
          if ds_exists(self.step_event_queues_temp, ds_type_priority){
            ds_priority_destroy(self.step_event_queues_temp)
            self.step_event_queues_temp = -1
          }
          if ds_exists(self.step_event_queues, ds_type_priority){
            ds_priority_destroy(self.step_event_queues)
            self.step_event_queues = -1
          }
          ///////////////////////////////////////////////////////
          
      self.collide = true
      self.pre_collide = false
    
    }
  }  
    
    
    
  ////////////////////////////////////////////////////////////////////
  //collision modifiers
  ////////////////////////////////////////////////////////////////////
  if self.collide &amp;&amp; !self.pre_collide  //if officially collided
  {
    
    //show_debug_message("proj - Collision event")
      var self.result = scr_run_modifiers() //collision modifiers
      if self.result = true
      {
        
        if ds_exists(self.weapon_event_queues, ds_type_priority)
        {
          ds_priority_destroy(self.weapon_event_queues)
          self.weapon_event_queues = -1
        }
        speed = 0
        
        if place_meeting(x,y, obj_entity){
          var enemy = nearest_enemy(x, y, w_hype)
          if (enemy != noone)
          {
              deal_damage(enemy, w_damage)
              draw_particle_blood(enemy.x, enemy.y)
              
              deal_knockback(enemy, w_knockback, direction)
            }
        }
        ///if aeo change sprite
        ///if aoe AND constant change sprite to rune
        ///if constant have colliders run on the player (or an object?)
        //either do your damage, or turn into an AOE effect
        self.constant_timer--
        if (self.constant_timer &lt;= 0)
        {instance_destroy()}
      }
  }

}//end of if active
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Disable collision checks if to many projectiles are nearby
if (collision_active) &amp;&amp; (!queued_to_del){
  
  if (instance_number(obj_weap_proj) &gt; 200) &amp;&amp; to_much_lag(){
    if (1*lag() &gt; obj_lag_controller.skipped_steps)
    || (fps &lt; 20){
        collision_active = false;
        //visible = false
        queued_to_del = true
    }
  }
  
  /*
  if (collision_active){
    var proj_count = collision_circle_list(x, y, 8, obj_weap_proj, -1, true)
    if (proj_count = noone) {
      exit;
    }else{
      if (ds_list_size(proj_count) &gt; 32){
        collision_active = false;
      }
      ds_list_destroy(proj_count)
    }
  }*/

}else{
  
  if to_much_lag(){
    if (queued_to_del){
      //instance_destroy()
      //show_debug_player("deleted")
    }else{
      queued_to_del = true
    }
  }else{ //if there is no longer too much lag
    if (queued_to_del){
      queued_to_del = false
    }
  }
 collision_active = true
 //visible = true
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="77">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///reset draw variables

predraw_finished = false
draw_finished = false
postdraw_finished = false

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw modifiers

if not (predraw_finished){
  if projectile_active &amp;&amp; is_visible(){
    with (obj_weap_proj){
      //if there is too much lag, or the predraw was already finished
      if (self.projectile_active) &amp;&amp; is_visible(){
        if (self.predraw_finished = true)
        //|| to_much_lag()
        {
          break;
        }else{
          self.predraw_finished = true
          if (self.is_lasered){
            draw_laser(self.previous_locations_path)
          }
          
          if (self.is_arcLightning){
            draw_arcLightning()
          }
        
          
        }
      }
    }
  }
}

if (is_airstrike) &amp;&amp; !enough_lag(){
      draw_airStrike()
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw Self
if (projectile_active) &amp;&amp; is_visible(){
  if sprite_exists(sprite_index){
    shader_set_hue(owner_id.fav_hue)
    draw_self()
    shader_reset()
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
