<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_weap_test</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>dis_traveled = 0
do_not_collide = false
collide_ground = false
collide_enemy  = false
collide_solid  = false
collision_active = true

w_range = 16*10  //this value is only here incase we have an error
self.collide = false
self.pre_collide = false

///  we now activate all projectiles after the spawn projectiles mods are finished,
//     to prevent them from trying to run their modifiers which they dont have yet.
self.projectile_active = false

self.active_queue = -1
self.weapon_event_queues = -1

self.step_event_queues = -1
self.step_event_queues_temp = -1

self.pre_col_queues = -1
self.pre_col_queues_temp = -1

self.constant_timer = 0


previous_locations_steps = room_speed*0.1
previous_locations_step = 0
previous_locations_i = 0

//previous_locations_array[0, 0] = x
//previous_locations_array[0, 1] = y

previous_locations_path = path_add();
path_set_closed(previous_locations_path, false);
path_add_point(previous_locations_path, x, y, speed);


///modifier variables
is_lasered = false
is_clustered = false
is_airstrike = false
is_arcLightning = false

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///init breakable object

//initialize breakable object (typically in the create event)
breaking = false
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///destroy left over paths

path_delete(previous_locations_path)
if (collision_active)
&amp;&amp; !variable_instance_exists(self.id, "aoe_start"){
  draw_sprite_explode(sprite_index)
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///clean up left over queues

if ds_exists(self.pre_col_queues_temp, ds_type_priority){
            ds_priority_destroy(self.pre_col_queues_temp)
            self.pre_col_queues_temp = -1
          }
          if ds_exists(self.pre_col_queues, ds_type_priority){
            ds_priority_destroy(self.pre_col_queues)
            self.pre_col_queues = -1
          }
          if ds_exists(self.step_event_queues_temp, ds_type_priority){
            ds_priority_destroy(self.step_event_queues_temp)
            self.step_event_queues_temp = -1
          }
          if ds_exists(self.step_event_queues, ds_type_priority){
            ds_priority_destroy(self.step_event_queues)
            self.step_event_queues = -1
          }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///store previous locations
if projectile_active{
  previous_locations_step += 1
  
  if (previous_locations_step = previous_locations_steps){
      previous_locations_step = 0
      previous_locations_i +=1
      
      previous_locations_array[previous_locations_i, 0] = x
      previous_locations_array[previous_locations_i, 1] = y
      path_add_point(previous_locations_path, x, y, speed);
      //show_debug_message("Stored new value")
  }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Run Modifiers

if projectile_active {
  ////////////////////////////////////////////////////////////////////
  //Attack step event
  ////////////////////////////////////////////////////////////////////
  if !self.collide &amp;&amp; !self.pre_collide  //if spawning projectiles
  {
    //show_debug_message("proj - Attack step event")
    
    if !ds_exists(self.step_event_queues, ds_type_priority)
    {
      self.step_event_queues = ds_priority_create()
      ds_priority_copy(self.step_event_queues, ds_priority_delete_min(self.weapon_event_queues))
    }
    
    //dont delete the queue untill the collision actually happens
    //so instead we make a copy to deal with
    if !ds_exists(self.step_event_queues_temp, ds_type_priority)
    {
      self.step_event_queues_temp = ds_priority_create()
      ds_priority_copy(self.step_event_queues_temp, self.step_event_queues)
    }
    
    //check to see if there is even anything in the step queue
    if !ds_priority_empty(self.step_event_queues){
      
      while !ds_priority_empty(self.step_event_queues_temp)
      {
        scr = script_execute(ds_priority_delete_min(self.step_event_queues_temp))
      }
      
      if ds_priority_empty(self.step_event_queues_temp)
      {
        ds_priority_copy(self.step_event_queues_temp, self.step_event_queues)
      }
    }
    
    ///if we are about to collide
    dis_traveled += speed
    if (collision_active){
      col_proj_ground()
      col_proj_solid()
      col_proj_enemy() //this function will not activate when colliding with an ally or a friendly summon
    }else{
      instance_destroy()
    }
  }
  
  
  ////////////////////////////////////////////////////////////////////
  //Pre collision modifiers
  ////////////////////////////////////////////////////////////////////
  if !self.collide &amp;&amp; self.pre_collide //if collision is detected, before collision is for sure
  {
    //show_debug_message("proj - Pre collision modifiers")
    
    self.do_not_collide = false
    
    if !ds_exists(self.pre_col_queues, ds_type_priority)
    {
      self.pre_col_queues = ds_priority_create()
      ds_priority_copy(self.pre_col_queues, ds_priority_delete_min(self.weapon_event_queues))
    }
    //dont delete the queue untill the collision actually happens
    //so instead we make a copy to deal with
    if !ds_exists(self.pre_col_queues_temp, ds_type_priority){
      self.pre_col_queues_temp = ds_priority_create()
      ds_priority_copy(self.pre_col_queues_temp, self.pre_col_queues)
    }
    
    //cycle through all pre collision modifiers, when the modifier is finished it'll return true
    while !ds_priority_empty(self.pre_col_queues_temp){
      var scr = ds_priority_delete_min(self.pre_col_queues_temp)
      var returned = script_execute(scr)
      if (returned = true) {ds_priority_delete_value(self.pre_col_queues, scr)}
    }
    
    //refill the temp list
    if ds_priority_empty(self.pre_col_queues_temp){
      ds_priority_copy(self.pre_col_queues_temp, self.pre_col_queues)
    }
    
    
    //if pre coliisions are empty then we must have collided
    if (ds_priority_empty(self.pre_col_queues) || !do_not_collide) &amp;&amp; self.collide = false &amp;&amp; self.pre_collide = true{
          ////if collision is final destroy the left over queues
          if ds_exists(self.pre_col_queues_temp, ds_type_priority){
            ds_priority_destroy(self.pre_col_queues_temp)
            self.pre_col_queues_temp = -1
          }
          if ds_exists(self.pre_col_queues, ds_type_priority){
            ds_priority_destroy(self.pre_col_queues)
            self.pre_col_queues = -1
          }
          if ds_exists(self.step_event_queues_temp, ds_type_priority){
            ds_priority_destroy(self.step_event_queues_temp)
            self.step_event_queues_temp = -1
          }
          if ds_exists(self.step_event_queues, ds_type_priority){
            ds_priority_destroy(self.step_event_queues)
            self.step_event_queues = -1
          }
          ///////////////////////////////////////////////////////
          
      self.collide = true
      self.pre_collide = false
    
    }
  }  
    
    
    
  ////////////////////////////////////////////////////////////////////
  //collision modifiers
  ////////////////////////////////////////////////////////////////////
  if self.collide &amp;&amp; !self.pre_collide  //if officially collided
  {
    
    //show_debug_message("proj - Collision event")
      var self.result = scr_run_modifiers() //collision modifiers
      if self.result = true
      {
        
        if ds_exists(self.weapon_event_queues, ds_type_priority)
        {
          ds_priority_destroy(self.weapon_event_queues)
          self.weapon_event_queues = -1
        }
        speed = 0
        
        if place_meeting(x,y, obj_entity){
          var enemy = nearest_enemy(x, y, w_hype)
          if (enemy != noone)
          {
              enemy.e_health -= w_damage
              //show_debug_message("fucked up")
              draw_particle_blood(enemy.x, enemy.y)
              
              enemy.spd = self.w_knockback
              enemy.direction = direction //point_direction(x, y, enemy.x, enemy.y)
            }
        }
        ///if aeo change sprite
        ///if aoe AND constant change sprite to rune
        ///if constant have colliders run on the player (or an object?)
        //either do your damage, or turn into an AOE effect
        self.constant_timer--
        if (self.constant_timer &lt;= 0)
        {instance_destroy()}
      }
  }

}//end of if active
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Disable collision checks if to many projectiles are nearby
/*
if (instance_number(obj_weap_proj) &gt;= (1000/global.numberOfLocalPlayers)){
  collision_active = false;
}

/*
if (collision_active = true){
  var proj_count = collision_circle_list(x, y, 8, obj_weap_proj, -1, true)
  if (proj_count = noone) {
    exit;
  }else{
    if (ds_list_size(proj_count) &gt; 32){
      collision_active = false;
    }
    ds_list_destroy(proj_count)
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw modifiers

if projectile_active{
  if (is_lasered){
    draw_laser(previous_locations_path)
  }
  
  if (is_arcLightning){
    draw_arcLightning()
  }
}

if (is_airstrike){
  draw_airStrike()
}



</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw Self
if (projectile_active){
  if sprite_exists(sprite_index){
    shader_set_hue(owner_id.fav_hue)
    draw_self()
    shader_reset()
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
